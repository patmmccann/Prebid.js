import path from 'path'
import fs from 'fs'
import helpers from '../gulpHelpers.js'
import allMetadata from './modules.json' with {type: 'json'}
import overrides from './overrides.mjs'
import { fetchDisclosure, getDisclosureUrl } from './storageDisclosure.mjs'

function matches (moduleName, moduleSuffix) {
  moduleSuffix = moduleSuffix.toLowerCase()
  const shortName = moduleName.toLowerCase().replace(moduleSuffix, '')
  return function ({ componentName, aliasOf }) {
    const name = (aliasOf ?? componentName).toLowerCase()
    return name === shortName || (name.startsWith(shortName) && moduleSuffix.startsWith(name.slice(shortName.length)))
  }
}

const modules = {
  BidAdapter: 'bidder',
  AnalyticsAdapter: 'analytics',
  IdSystem: 'userId',
  RtdProvider: 'rtd'
}

async function metadataFor (metas) {
  const disclosures = {}
  for (const meta of metas) {
    if (meta.disclosureURL == null && meta.gvlid != null) {
      meta.disclosureURL = await getDisclosureUrl(meta.gvlid)
    }
    if (meta.disclosureURL) {
      disclosures[meta.disclosureURL] = fetchDisclosure(meta)
    }
  }
  for (const [url, promise] of Object.entries(disclosures)) {
    disclosures[url] = await promise
  }
  return {
    "NOTICE": "do not edit - this file is autogenerated by `gulp update-metadata`",
    disclosures,
    components: metas
  }
}

export default async function compileMetadata() {
  const found = new WeakSet();
  let err = false
  for (const moduleName of helpers.getModuleNames()) {
    let predicate
    for (const [suffix, moduleType] of Object.entries(modules)) {
      if (moduleName.endsWith(suffix)) {
        predicate = overrides.hasOwnProperty(moduleName)
          ? ({ componentName, aliasOf }) => componentName === overrides[moduleName] || aliasOf === overrides[moduleName]
          : matches(moduleName, suffix)
        predicate = ((orig) => (entry) => entry.componentType === moduleType && orig(entry))(predicate)
        break
      }
    }
    if (predicate) {
      const meta = allMetadata.filter(predicate)
      meta.forEach((entry) => found.add(entry))
      const names = new Set(meta.map(({ componentName, aliasOf }) => aliasOf ?? componentName))
      if (names.size === 0) {
        console.error('Cannot determine module name for module file: ', moduleName)
        err = true
      } else if (names.size > 1) {
        console.error('More than one module name matches module file:', moduleName, names)
        err = true
      } else {
        const moduleMetadata = await metadataFor(meta)
        fs.writeFileSync(path.resolve(`./metadata/modules/${moduleName}.json`), JSON.stringify(moduleMetadata, null, 2))
      }
    }
  }

  const notFound = allMetadata.filter(entry => !found.has(entry))
  if (notFound.length > 0) {
    console.error('Could not find module name for metadata', notFound)
    err = true
  }

  if (err) {
    throw new Error('Could not compile module metadata')
  }
}
